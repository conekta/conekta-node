/* tslint:disable */
/* eslint-disable */
/**
 * Conekta API
 * Conekta sdk
 *
 * The version of the OpenAPI document: 2.1.0
 * Contact: engineering@conekta.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BlacklistRuleResponse,
  CreateRiskRulesData,
  DeletedBlacklistRuleResponse,
  DeletedWhitelistRuleResponse,
  ModelError,
  RiskRulesList,
  WhitelistlistRuleResponse,
} from '../models';
import {
    BlacklistRuleResponseFromJSON,
    BlacklistRuleResponseToJSON,
    CreateRiskRulesDataFromJSON,
    CreateRiskRulesDataToJSON,
    DeletedBlacklistRuleResponseFromJSON,
    DeletedBlacklistRuleResponseToJSON,
    DeletedWhitelistRuleResponseFromJSON,
    DeletedWhitelistRuleResponseToJSON,
    ModelErrorFromJSON,
    ModelErrorToJSON,
    RiskRulesListFromJSON,
    RiskRulesListToJSON,
    WhitelistlistRuleResponseFromJSON,
    WhitelistlistRuleResponseToJSON,
} from '../models';

export interface CreateRuleBlacklistRequest {
    createRiskRulesData: CreateRiskRulesData;
    acceptLanguage?: CreateRuleBlacklistAcceptLanguageEnum;
}

export interface CreateRuleWhitelistRequest {
    acceptLanguage?: CreateRuleWhitelistAcceptLanguageEnum;
    createRiskRulesData?: CreateRiskRulesData;
}

export interface DeleteRuleBlacklistRequest {
    id: string;
    acceptLanguage?: DeleteRuleBlacklistAcceptLanguageEnum;
    xChildCompanyId?: string;
}

export interface DeleteRuleWhitelistRequest {
    id: string;
    acceptLanguage?: DeleteRuleWhitelistAcceptLanguageEnum;
    xChildCompanyId?: string;
}

export interface GetRuleBlacklistRequest {
    acceptLanguage?: GetRuleBlacklistAcceptLanguageEnum;
}

export interface GetRuleWhitelistRequest {
    acceptLanguage?: GetRuleWhitelistAcceptLanguageEnum;
}

/**
 * 
 */
export class AntifraudApi extends runtime.BaseAPI {

    /**
     * Create blacklisted rule
     */
    async createRuleBlacklistRaw(requestParameters: CreateRuleBlacklistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlacklistRuleResponse>> {
        if (requestParameters.createRiskRulesData === null || requestParameters.createRiskRulesData === undefined) {
            throw new runtime.RequiredError('createRiskRulesData','Required parameter requestParameters.createRiskRulesData was null or undefined when calling createRuleBlacklist.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/antifraud/blacklists`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRiskRulesDataToJSON(requestParameters.createRiskRulesData),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlacklistRuleResponseFromJSON(jsonValue));
    }

    /**
     * Create blacklisted rule
     */
    async createRuleBlacklist(requestParameters: CreateRuleBlacklistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlacklistRuleResponse> {
        const response = await this.createRuleBlacklistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create whitelisted rule
     */
    async createRuleWhitelistRaw(requestParameters: CreateRuleWhitelistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<WhitelistlistRuleResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/antifraud/whitelists`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateRiskRulesDataToJSON(requestParameters.createRiskRulesData),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => WhitelistlistRuleResponseFromJSON(jsonValue));
    }

    /**
     * Create whitelisted rule
     */
    async createRuleWhitelist(requestParameters: CreateRuleWhitelistRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<WhitelistlistRuleResponse> {
        const response = await this.createRuleWhitelistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete blacklisted rule
     */
    async deleteRuleBlacklistRaw(requestParameters: DeleteRuleBlacklistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeletedBlacklistRuleResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteRuleBlacklist.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.xChildCompanyId !== undefined && requestParameters.xChildCompanyId !== null) {
            headerParameters['X-Child-Company-Id'] = String(requestParameters.xChildCompanyId);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/antifraud/blacklists/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeletedBlacklistRuleResponseFromJSON(jsonValue));
    }

    /**
     * Delete blacklisted rule
     */
    async deleteRuleBlacklist(requestParameters: DeleteRuleBlacklistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeletedBlacklistRuleResponse> {
        const response = await this.deleteRuleBlacklistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete whitelisted rule
     */
    async deleteRuleWhitelistRaw(requestParameters: DeleteRuleWhitelistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeletedWhitelistRuleResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteRuleWhitelist.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (requestParameters.xChildCompanyId !== undefined && requestParameters.xChildCompanyId !== null) {
            headerParameters['X-Child-Company-Id'] = String(requestParameters.xChildCompanyId);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/antifraud/whitelists/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeletedWhitelistRuleResponseFromJSON(jsonValue));
    }

    /**
     * Delete whitelisted rule
     */
    async deleteRuleWhitelist(requestParameters: DeleteRuleWhitelistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeletedWhitelistRuleResponse> {
        const response = await this.deleteRuleWhitelistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return all rules
     * Get list of blacklisted rules
     */
    async getRuleBlacklistRaw(requestParameters: GetRuleBlacklistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RiskRulesList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/antifraud/blacklists`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RiskRulesListFromJSON(jsonValue));
    }

    /**
     * Return all rules
     * Get list of blacklisted rules
     */
    async getRuleBlacklist(requestParameters: GetRuleBlacklistRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RiskRulesList> {
        const response = await this.getRuleBlacklistRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return all rules
     * Get a list of whitelisted rules
     */
    async getRuleWhitelistRaw(requestParameters: GetRuleWhitelistRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RiskRulesList>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.acceptLanguage !== undefined && requestParameters.acceptLanguage !== null) {
            headerParameters['Accept-Language'] = String(requestParameters.acceptLanguage);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/antifraud/whitelists`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RiskRulesListFromJSON(jsonValue));
    }

    /**
     * Return all rules
     * Get a list of whitelisted rules
     */
    async getRuleWhitelist(requestParameters: GetRuleWhitelistRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RiskRulesList> {
        const response = await this.getRuleWhitelistRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CreateRuleBlacklistAcceptLanguageEnum = {
    Es: 'es',
    En: 'en'
} as const;
export type CreateRuleBlacklistAcceptLanguageEnum = typeof CreateRuleBlacklistAcceptLanguageEnum[keyof typeof CreateRuleBlacklistAcceptLanguageEnum];
/**
 * @export
 */
export const CreateRuleWhitelistAcceptLanguageEnum = {
    Es: 'es',
    En: 'en'
} as const;
export type CreateRuleWhitelistAcceptLanguageEnum = typeof CreateRuleWhitelistAcceptLanguageEnum[keyof typeof CreateRuleWhitelistAcceptLanguageEnum];
/**
 * @export
 */
export const DeleteRuleBlacklistAcceptLanguageEnum = {
    Es: 'es',
    En: 'en'
} as const;
export type DeleteRuleBlacklistAcceptLanguageEnum = typeof DeleteRuleBlacklistAcceptLanguageEnum[keyof typeof DeleteRuleBlacklistAcceptLanguageEnum];
/**
 * @export
 */
export const DeleteRuleWhitelistAcceptLanguageEnum = {
    Es: 'es',
    En: 'en'
} as const;
export type DeleteRuleWhitelistAcceptLanguageEnum = typeof DeleteRuleWhitelistAcceptLanguageEnum[keyof typeof DeleteRuleWhitelistAcceptLanguageEnum];
/**
 * @export
 */
export const GetRuleBlacklistAcceptLanguageEnum = {
    Es: 'es',
    En: 'en'
} as const;
export type GetRuleBlacklistAcceptLanguageEnum = typeof GetRuleBlacklistAcceptLanguageEnum[keyof typeof GetRuleBlacklistAcceptLanguageEnum];
/**
 * @export
 */
export const GetRuleWhitelistAcceptLanguageEnum = {
    Es: 'es',
    En: 'en'
} as const;
export type GetRuleWhitelistAcceptLanguageEnum = typeof GetRuleWhitelistAcceptLanguageEnum[keyof typeof GetRuleWhitelistAcceptLanguageEnum];
